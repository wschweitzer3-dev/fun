# APX Best Practices & Anti-Patterns

Guidelines for building high-quality APX applications. **Consult only when needed.**

## Critical Rules

### Backend

1. **Always include `response_model` and `operation_id`**
   ```python
   # ✅ Correct
   @api.get("/entities", response_model=list[EntityOut], operation_id="listEntities")

   # ❌ Wrong - missing both
   @api.get("/entities")
   ```

2. **Follow 3-model pattern**
   - `EntityIn` - Input validation
   - `EntityOut` - Complete output
   - `EntityListOut` - Performance-optimized summary

3. **Use descriptive operation_ids**
   - Pattern: `<verb><Entity>` (camelCase)
   - Examples: `listOrders`, `getOrder`, `createOrder`, `updateOrderStatus`

4. **Always use type hints**
   ```python
   # ✅ Correct
   def get_entity(entity_id: str) -> EntityOut:

   # ❌ Wrong - no types
   def get_entity(entity_id):
   ```

5. **Handle errors with HTTPException**
   ```python
   if entity_id not in db:
       raise HTTPException(status_code=404, detail="Not found")
   ```

### Frontend

1. **Always use Suspense hooks**
   ```typescript
   // ✅ Correct
   <Suspense fallback={<Skeleton />}>
     <DataComponent />
   </Suspense>

   function DataComponent() {
     const { data } = useListEntitiesSuspense(selector());
     return <div>{data.map(...)}</div>;
   }

   // ❌ Wrong - no Suspense
   const { data, isLoading } = useListEntities();
   if (isLoading) return <div>Loading...</div>;
   ```

2. **Use selector() for destructuring**
   ```typescript
   // ✅ Correct
   const { data: entities } = useListEntitiesSuspense(selector());

   // ❌ Wrong - verbose
   const result = useListEntitiesSuspense();
   const entities = result.data;
   ```

3. **Provide matching skeleton fallbacks**
   - Skeleton should mirror actual content structure
   - Use same table/card layout

4. **Never edit auto-generated files**
   - `lib/api.ts` - Generated by Orval
   - `types/routeTree.gen.ts` - Generated by TanStack Router

5. **Implement proper formatters**
   - Currency: `Intl.NumberFormat`
   - Dates: `toLocaleDateString`
   - Status colors: Tailwind classes with dark mode support

## Anti-Patterns

### Backend

**❌ Missing response_model**
```python
@api.get("/entities")  # OpenAPI won't generate correctly
async def list_entities():
    return []
```

**❌ Generic operation_id**
```python
@api.get("/entities", operation_id="get")  # Too generic
```

**❌ No type safety**
```python
def process(data):  # Can't validate, no IDE support
    return data["field"]
```

**❌ Using plain dicts instead of Pydantic**
```python
def create_entity(data: dict):  # No validation
    return {"id": "123", **data}
```

### Frontend

**❌ Not using Suspense**
```typescript
const { data, isLoading } = useListEntities();
if (isLoading) return <Loading />;  // Manual loading state
```

**❌ Editing generated files**
```typescript
// In lib/api.ts
export function useListEntities() {
  // Custom changes ❌
}
```

**❌ No skeleton fallback**
```typescript
<Suspense>  {/* No fallback - will show nothing */}
  <DataComponent />
</Suspense>
```

**❌ Inline styles or classes**
```typescript
<div style={{ color: 'red' }}>  {/* No dark mode support */}
```

## Type Safety

### Python Type Errors

**Problem**: Dict access typing
```python
# ❌ Problem
item_data["field"]  # Type checker doesn't know structure
```

**Solution**: Explicit casting
```python
# ✅ Solution
if not isinstance(item_data, dict):
    continue
item_dict: dict[str, Any] = item_data
value = str(item_dict.get("field", ""))
```

**Problem**: Optional fields
```python
# ❌ Problem
entity.notes.upper()  # notes is Optional[str]
```

**Solution**: Check before access
```python
# ✅ Solution
if entity.notes:
    entity.notes.upper()
```

### TypeScript Type Errors

**Problem**: Wrong destructuring
```typescript
// ❌ Problem
const { data: response } = useListEntitiesSuspense(selector());
const entities = response.data;  // response.data doesn't exist
```

**Solution**: Direct destructuring
```typescript
// ✅ Solution
const { data: entities } = useListEntitiesSuspense(selector());
```

## Performance

### Backend

1. **Use EntityListOut for lists** - Don't return full EntityOut for performance
2. **Implement pagination** - For large datasets
3. **Use async** - For I/O operations
4. **Index database queries** - When replacing mock data

### Frontend

1. **Use EntityListOut endpoints** - Lists should use summary endpoints
2. **Implement virtual scrolling** - For very long lists
3. **Lazy load detail views** - Don't preload all details
4. **Use React.memo** - Only when profiling shows benefit

## Code Organization

### Backend

```
backend/
├── models.py      # All Pydantic models
├── router.py      # All API routes
├── dependencies.py # Shared dependencies
├── config.py      # Configuration
└── utils.py       # Helper functions
```

**Don't**: Split models/routes across multiple files unless >1000 lines

### Frontend

```
ui/
├── routes/
│   └── _sidebar/
│       ├── entities.tsx           # List page
│       └── entities.$entityId.tsx # Detail page
├── components/
│   ├── ui/           # shadcn components (don't edit)
│   └── apx/          # Custom components
└── lib/
    ├── api.ts        # Auto-generated (don't edit)
    ├── utils.ts      # Helpers (cn, etc.)
    └── selector.ts   # Query selector
```

**Do**: Keep list and detail pages together
**Don't**: Create deep nested route folders

## Error Messages

### Backend

```python
# ✅ Descriptive
raise HTTPException(
    status_code=404,
    detail=f"Entity with ID {entity_id} not found"
)

# ❌ Generic
raise HTTPException(status_code=404, detail="Not found")
```

### Frontend

```typescript
// ✅ User-friendly
console.error("Failed to delete order:", error);
// Show toast/alert to user

// ❌ Silent failure
try {
  await deleteEntity.mutateAsync({ entityId });
} catch {}  // Silently swallows error
```

## Testing

### Backend

```bash
# Type check
uv run basedpyright --level error

# Test endpoints
curl http://localhost:8000/api/entities | jq .
curl http://localhost:8000/api/entities/{id} | jq .
```

### Frontend

```bash
# Type check
bun run tsc -b --incremental

# Both
uv run apx dev check
```

## Common Pitfalls

1. **Forgetting to wait for OpenAPI regeneration** - Wait 5-10 seconds after backend changes
2. **Running shadcn from wrong directory** - Must run from project root
3. **Not using --yes flag** - Shadcn will prompt for confirmation
4. **Editing auto-generated files** - Changes will be overwritten
5. **Not implementing skeleton fallbacks** - Page will appear broken while loading
6. **Inconsistent status colors** - Use same color scheme throughout
7. **No dark mode support** - Always use Tailwind dark: classes

## Debugging Checklist

**Backend issues**:
- [ ] All models use type hints
- [ ] All routes have response_model + operation_id
- [ ] Mock data initialized correctly
- [ ] Type checking passes

**Frontend issues**:
- [ ] OpenAPI client regenerated (check timestamp on lib/api.ts)
- [ ] Using Suspense hooks
- [ ] Suspense boundaries in place
- [ ] Hook names match operation_ids
- [ ] Type checking passes

**Integration issues**:
- [ ] Backend servers running (apx dev status)
- [ ] OpenAPI watcher running
- [ ] API returns correct data (curl test)
- [ ] Frontend URL accessible
